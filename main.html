<!DOCTYPE html>
<html>
  <head>
    <script type="text/javascript">
      let ctx = null;
      const tileW = 40,
        tileH = 40;
      const mapW = 20,
        mapH = 20;

      let currentSecond = 0,
        frameCount = 0,
        framesLastSecond = 0;
      let lastFrameTime = 0;

      let tileset = null,
        tilesetURL = "tileset.png",
        tilesetLoaded = false;

      const keysDown = {
        37: false, // LEFT
        38: false, // DOWN
        39: false, // UP
        40: false, // RIGHT
      };
      let gameTime = 0;
      const gameSpeeds = [
        { name: "Normal", mult: 1 },
        { name: "Slow", mult: 0.3 },
        { name: "Fast", mult: 3 },
        { name: "Paused", mult: 0 },
      ];
      let currentGameSpeed = 0;
      const objectCollision = {
        none: 0,
        solid: 1,
      };
      const objectTypes = {
        1: {
          name: "Box",
          sprite: [{ x: 40, y: 160, w: 40, h: 40 }],
          offset: [0, 0],
          collision: objectCollision.solid,
          zIndex: 1,
        },
        2: {
          name: "Broken Box",
          sprite: [{ x: 40, y: 200, w: 40, h: 40 }],
          offset: [0, 0],
          collision: objectCollision.none,
          zIndex: 1,
        },
        3: {
          name: "Tree top",
          sprite: [{ x: 80, y: 160, w: 80, h: 80 }],
          offset: [-20, -20], //TODO: 수정하면서 보기
          collision: objectCollision.solid,
          zIndex: 3,
        },
      };
      const itemTypes = {
        1: {
          name: "Star",
          maxStack: 2,
          sprite: [{x:240, y:0, w:40, h:40}],
          offset: [0,0],
        }
      }
      function Stack(id, qty){
        this.type = id;
        this.qty = qty;
      }
      function Inventory(s){
        this.spaces = s;
        this.stacks = [];
      }
      Inventory.prototype.addItems = function(id, qty){
        for(let i=0; i<this.spaces; i++){
          if(this.stacks.length <= i){
            let maxHere = (qty > itemTypes[id].maxStack ?
                            itemTypes[id].maxStack : qty);
            this.stacks.push(new Stack(id, maxHere));
            qty -= maxHere;
          } else if (this.stacks[i].type == id &&
                    this.stacks[i].qty < itemTypes[id].maxStack){
            let maxHere = (itemTypes[id].maxStack - this.stacks[i].qty);
            if(maxHere > qty) { maxHere = qty; }

            this.stacks[i].qty += maxHere;
            qty -= maxHere;
          }
          if(qty == 0){ return 0; }
        }
        return qty;
      }
      function PlacedItemStack(id, qty){
        this.type = id;
        this.qty = qty;
        this.x = 0;
        this.y = 0;
      }
      PlacedItemStack.prototype.placeAt = function(nx, ny){
        if(mapTileData.map[toIndex(this.x, this.y)].itemStack == this){
          mapTileData.map[toIndex(this.x, this.y)].itemStack = null;
        }
        this.x = nx;
        this.y = ny;

        mapTileData.map[toIndex(nx, ny)].itemStack = this;
      }
      function MapObject(nt) {
        this.x = 0;
        this.y = 0;
        this.type = nt;
      }
      MapObject.prototype.placeAt = function (nx, ny) {
        if (mapTileData.map[toIndex(this.x, this.y)].object == this) {
          mapTileData.map[toIndex(this.x, this.y)].object = null;
        }
        this.x = nx;
        this.y = ny;

        mapTileData.map[toIndex(nx, ny)].object = this;
      };

      const gameMap = [
        0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 2, 2, 2, 1, 1, 1, 1,
        1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 2, 1, 0, 0, 0, 0, 4, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 2, 1, 0, 2, 2, 0, 4, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 1, 1, 2, 1, 0, 2, 2, 0, 4, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
        0, 1, 1, 2, 2, 2, 2, 2, 0, 4, 4, 4, 1, 1, 1, 0, 2, 2, 2, 0, 0, 1, 1, 2,
        1, 0, 2, 2, 0, 1, 1, 4, 1, 1, 1, 0, 2, 2, 2, 0, 0, 1, 1, 2, 1, 0, 2, 2,
        0, 1, 1, 4, 1, 1, 1, 0, 2, 2, 2, 0, 0, 1, 1, 2, 1, 0, 0, 0, 0, 1, 1, 4,
        1, 1, 0, 0, 0, 2, 0, 0, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 0, 2,
        2, 2, 2, 0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 1, 4, 4, 1, 1, 0, 2, 2, 2, 2, 0,
        0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 4, 4, 1, 1, 1, 0, 2, 2, 2, 2, 0, 0, 1, 1, 1, 1, 1, 1, 1,
        1, 4, 1, 1, 1, 1, 0, 2, 2, 2, 2, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
        0, 1, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      ];
      const mapTileData = new TileMap();
      const roofList = [
        {
          x: 5,
          y: 3,
          w: 4,
          h: 7,
          data: [
            10, 10, 11, 11, 10, 10, 11, 11, 10, 10, 11, 11, 10, 10, 11, 11, 10,
            10, 11, 11, 10, 10, 11, 11, 10, 10, 11, 11,
          ],
        },
        {
          x: 15,
          y: 5,
          w: 5,
          h: 4,
          data: [
            10, 10, 11, 11, 11, 10, 10, 11, 11, 11, 10, 10, 11, 11, 11, 10, 10,
            11, 11, 11,
          ],
        },
        {
          x: 14,
          y: 9,
          w: 6,
          h: 7,
          data: [
            10, 10, 10, 11, 11, 11, 10, 10, 10, 11, 11, 11, 10, 10, 10, 11, 11,
            11, 10, 10, 10, 11, 11, 11, 10, 10, 10, 11, 11, 11, 10, 10, 10, 11,
            11, 11, 10, 10, 10, 11, 11, 11,
          ],
        },
      ];
      const floorTypes = {
        solid: 0,
        path: 1,
        water: 2,
        ice: 3,
        conveyorU: 4,
        conveyorD: 5,
        conveyorL: 6,
        conveyorR: 7,
        grass: 8,
      };
      const tileTypes = {
        0: {
          color: "#685b48",
          floor: floorTypes.solid,
          sprite: [{ x: 0, y: 0, w: 40, h: 40 }],
        },
        1: {
          color: "#5aa457",
          floor: floorTypes.grass,
          sprite: [{ x: 40, y: 0, w: 40, h: 40 }],
        },
        2: {
          color: "#e8bd7a",
          floor: floorTypes.path,
          sprite: [{ x: 80, y: 0, w: 40, h: 40 }],
        },
        3: {
          color: "#286625",
          floor: floorTypes.solid,
          sprite: [{ x: 120, y: 0, w: 40, h: 40 }],
        },
        4: {
          color: "#eeeeff",
          floor: floorTypes.water,
          sprite:[
            {x:160,y:0,w:40,h:40,d:200}, {x:200,y:0,w:40,h:40,d:200},
            {x:160,y:40,w:40,h:40,d:200}, {x:200,y:40,w:40,h:40,d:200},
            {x:160,y:40,w:40,h:40,d:200}, {x:200,y:0,w:40,h:40,d:200}
          ]},
        5 : { colour:"#eeeeff", floor:floorTypes.ice,	sprite:[{x:120,y:120,w:40,h:40}]},
        6: {
          color: "#000000",
          floor: floorTypes.conveyorL,
          sprite: [
            { x: 0, y: 40, w: 40, h: 40, d: 200 },
            { x: 40, y: 40, w: 40, h: 40, d: 200 },
            { x: 80, y: 40, w: 40, h: 40, d: 200 },
            { x: 120, y: 40, w: 40, h: 40, d: 200 },
          ],
        },
        7: {
          color: "#000000",
          floor: floorTypes.conveyorR,
          sprite: [
            { x: 120, y: 80, w: 40, h: 40, d: 200 },
            { x: 80, y: 80, w: 40, h: 40, d: 200 },
            { x: 40, y: 80, w: 40, h: 40, d: 200 },
            { x: 0, y: 80, w: 40, h: 40, d: 200 },
          ],
        },
        8: {
          color: "#000000",
          floor: floorTypes.conveyorD,
          sprite: [
            { x: 160, y: 200, w: 40, h: 40, d: 200 },
            { x: 160, y: 160, w: 40, h: 40, d: 200 },
            { x: 160, y: 120, w: 40, h: 40, d: 200 },
            { x: 160, y: 80, w: 40, h: 40, d: 200 },
          ],
        },
        9: {
          color: "#000000",
          floor: floorTypes.conveyorU,
          sprite: [
            { x: 200, y: 80, w: 40, h: 40, d: 200 },
            { x: 200, y: 120, w: 40, h: 40, d: 200 },
            { x: 200, y: 160, w: 40, h: 40, d: 200 },
            { x: 200, y: 200, w: 40, h: 40, d: 200 },
          ],
        },
        10: {
          color: "#ccaa00",
          floor: floorTypes.solid,
          sprite: [{ x: 40, y: 120, w: 40, h: 40 }],
        },
        11: {
          color: "#ccaa00",
          floor: floorTypes.solid,
          sprite: [{ x: 80, y: 120, w: 40, h: 40 }],
        },
      };
      function Tile(tx, ty, tt) {
        this.x = tx;
        this.y = ty;
        this.type = tt;
        this.roof = null;
        this.roofType = 0;
        this.eventEnter = null;
        this.object = null;
        this.itemStack = null;
      }
      function TileMap() {
        this.map = [];
        this.w = 0;
        this.h = 0;
        this.levels = 4;
      }
      TileMap.prototype.buildMapFromData = function (d, w, h) {
        this.w = w;
        this.h = h;
        if (d.length != w * h) return false;
        this.map.length = 0;
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            this.map.push(new Tile(x, y, d[(y * w)+ x]));
          }
        }
        return true;
      };
      TileMap.prototype.addRoofs = function (roofs) {
        for (let i in roofs) {
          let r = roofs[i];
          if (
            r.x < 0 ||
            r.y < 0 ||
            r.x >= this.w ||
            r.y >= this.h ||
            r.x + r.w > this.w ||
            r.y + r.h > this.h ||
            r.data.length != r.w * r.h
          ) {
            continue;
          }

          for (let y = 0; y < r.h; y++) {
            for (let x = 0; x < r.w; x++) {
              let tileIdx = (r.y + y) * this.w + r.x + x;
              this.map[tileIdx].roof = r;
              this.map[tileIdx].roofType = r.data[y * r.w + x];
            }
          }
        }
      };

      const directions = {
        up: 0,
        right: 1,
        down: 2,
        left: 3,
      };

      const viewport = {
        screen: [0, 0],
        startTile: [0, 0], // top-left
        endTile: [0, 0], //bottom-right
        offset: [0, 0], // x, y pxcel, center of screen?
        update: function (px, py) {
          this.offset[0] = Math.floor(this.screen[0] / 2 - px);
          this.offset[1] = Math.floor(this.screen[1] / 2 - py);
          //TODO: 수학적으로 어떻게 계산되는지 정리하기
          const tile = [Math.floor(px / tileW), Math.floor(py / tileH)];

          this.startTile[0] =
            tile[0] - 1 - Math.ceil(this.screen[0] / 2 / tileW);
          this.startTile[1] =
            tile[1] - 1 - Math.ceil(this.screen[1] / 2 / tileH);

          if (this.startTile[0] < 0) {
            this.startTile[0] = 0;
          }
          if (this.startTile[1] < 0) {
            this.startTile[1] = 0;
          }
          this.endTile[0] = tile[0] + 1 + Math.ceil(this.screen[0] / 2 / tileW);
          this.endTile[1] = tile[1] + 1 + Math.ceil(this.screen[1] / 2 / tileH);

          if (this.endTile[0] >= mapW) {
            this.endTile[0] = mapW - 1;
          }
          if (this.endTile[1] >= mapH) {
            this.endTile[1] = mapH - 1;
          }
        },
      };

      const player = new Character();

      function Character() {
        this.tileFrom = [1, 1];
        this.tileTo = [1, 1];
        this.timeMoved = 0;
        this.dimensions = [30, 30];
        this.position = [45, 45];

        this.delayMove = {};
        this.delayMove[floorTypes.path] = 200;
        this.delayMove[floorTypes.grass] = 400;
        this.delayMove[floorTypes.ice] = 300;
        this.delayMove[floorTypes.conveyorD] = 150;
        this.delayMove[floorTypes.conveyorU] = 150;
        this.delayMove[floorTypes.conveyorL] = 150;
        this.delayMove[floorTypes.conveyorR] = 150;

        this.direction = directions.up;
        this.sprites = {};
        this.sprites[directions.up] = [{ x: 0, y: 120, w: 30, h: 30 }];
        this.sprites[directions.right] = [{ x: 0, y: 150, w: 30, h: 30 }];
        this.sprites[directions.down] = [{ x: 0, y: 180, w: 30, h: 30 }];
        this.sprites[directions.left] = [{ x: 0, y: 210, w: 30, h: 30 }];

        this.inventory = new Inventory(3);
      }

      Character.prototype.placeAt = function (x, y) {
        console.log(x, y);
        this.tileFrom = [x, y];
        this.tileTo = [x, y];
        this.position = [
          tileW * x + (tileW - this.dimensions[0]) / 2,
          tileH * y + (tileH - this.dimensions[1]) / 2,
        ];
      };
      Character.prototype.processMovement = function (t) {
        if (
          this.tileTo[0] == this.tileFrom[0] &&
          this.tileTo[1] == this.tileFrom[1]
        ) {
          // 안움직일 때.(목표랑 현재가 같을 때)
          return false;
        }
        // 아래부터는 움직일 때인데 이전 frame이랑 현재 frame간의 시간차와 moveSpeed를 이용해서 이동해야하는 정도를 계산해서 position을 갱신함.
        const moveSpeed =
          this.delayMove[
            tileTypes[
              mapTileData.map[toIndex(this.tileFrom[0], this.tileFrom[1])].type
            ].floor
          ];
        // this.timeMoved: 이전에 움직인 시간
        // t: 지금 시간
        // t-this.timeMoved: 시간, moveSpeed: 속력이긴 한데 시간이라 볼 수 있음. 차라리 moveThreshold?같은 느낌
        // - 이전 시간(t)으로부터 정해진 시간(moveSpeed)이 지나야지 placeAt(실제로 tileFrom, tileTo를 동기화)가 발동됨.
        if (t - this.timeMoved >= moveSpeed) {
          this.placeAt(this.tileTo[0], this.tileTo[1]);

          if (
            mapTileData.map[toIndex(this.tileTo[0], this.tileTo[1])]
              .eventEnter != null
          ) {
            mapTileData.map[toIndex(this.tileTo[0], this.tileTo[1])].eventEnter(
              this
            );
          }

          const tileFloor =
            tileTypes[
              mapTileData.map[toIndex(this.tileFrom[0], this.tileFrom[1])].type
            ].floor;

          // 그렇게 도착한 tile type에 따라서 각기 다른 동작들이 수행됨.
          if (tileFloor === floorTypes.ice) {
            if (this.canMoveDirection(this.direction)) {
              this.moveDirection(this.direction, t);
            }
          } else if (tileFloor === floorTypes.conveyorL && this.canMoveLeft()) {
            this.moveLeft(t);
          } else if (tileFloor === floorTypes.conveyorU && this.canMoveUp()) {
            this.moveUp(t);
          } else if (
            tileFloor === floorTypes.conveyorR &&
            this.canMoveRight()
          ) {
            this.moveRight(t);
          } else if (tileFloor === floorTypes.conveyorD && this.canMoveDown()) {
            this.moveDown(t);
          }
        } else {
          // 움직이는 중
          // pixel position

          // 중간 지점을 찾아준다. 이동할 stride?
          this.position[0] =
            this.tileFrom[0] * tileW + (tileW - this.dimensions[0]) / 2;
          this.position[1] =
            this.tileFrom[1] * tileH + (tileH - this.dimensions[1]) / 2;

          if (this.tileTo[0] != this.tileFrom[0]) {
            // Horizontally
            const diff = ((t - this.timeMoved) / moveSpeed) * tileW;
            this.position[0] +=
              this.tileTo[0] < this.tileFrom[0] ? 0 - diff : diff;
          }
          if (this.tileTo[1] != this.tileFrom[1]) {
            // Vertically
            const diff = ((t - this.timeMoved) / moveSpeed) * tileH;
            this.position[1] +=
              this.tileTo[1] < this.tileFrom[1] ? 0 - diff : diff;
          }
          this.position[0] = Math.round(this.position[0]);
          this.position[1] = Math.round(this.position[1]);
        }
        return true;
      };
      Character.prototype.canMoveTo = function (x, y) {
        if (x < 0 || x >= mapW || y < 0 || y >= mapH) {
          return false;
        }
        mapTileData.map[toIndex(player.tileFrom[0], player.tileFrom[1])].roof;
        if (
          typeof this.delayMove[
            tileTypes[mapTileData.map[toIndex(x, y)].type].floor
          ] === "undefined"
        ) {
          return false;
        }
        if (mapTileData.map[toIndex(x, y)].object != null) {
          const o = mapTileData.map[toIndex(x, y)].object;
          if (objectTypes[o.type].collision == objectCollision.solid) {
            return false;
          }
        }
        return true;
      };
      Character.prototype.canMoveDirection = function (d) {
        switch (d) {
          case directions.up:
            return this.canMoveUp();
          case directions.right:
            return this.canMoveRight();
          case directions.down:
            return this.canMoveDown();
          case directions.left:
            return this.canMoveLeft();
          default:
            console.error("unregistered direction");
            return false;
        }
      };
      Character.prototype.canMoveUp = function (x, y) {
        return this.canMoveTo(this.tileFrom[0], this.tileFrom[1] - 1);
      };
      Character.prototype.canMoveDown = function (x, y) {
        return this.canMoveTo(this.tileFrom[0], this.tileFrom[1] + 1);
      };
      Character.prototype.canMoveRight = function (x, y) {
        return this.canMoveTo(this.tileFrom[0] + 1, this.tileFrom[1]);
      };
      Character.prototype.canMoveLeft = function (x, y) {
        return this.canMoveTo(this.tileFrom[0] - 1, this.tileFrom[1]);
      };
      Character.prototype.moveLeft = function (t) {
        this.tileTo[0] -= 1;
        this.timeMoved = t;
        this.direction = directions.left;
      };
      Character.prototype.moveRight = function (t) {
        this.tileTo[0] += 1;
        this.timeMoved = t;
        this.direction = directions.right;
      };
      Character.prototype.moveUp = function (t) {
        this.tileTo[1] -= 1;
        this.timeMoved = t;
        this.direction = directions.up;
      };
      Character.prototype.moveDown = function (t) {
        this.tileTo[1] += 1;
        this.timeMoved = t;
        this.direction = directions.down;
      };
      Character.prototype.moveDirection = function (d, t) {
        switch (d) {
          case directions.up:
            return this.moveUp(t);
          case directions.right:
            return this.moveRight(t);
          case directions.down:
            return this.moveDown(t);
          case directions.left:
            return this.moveLeft(t);
          default:
            console.error("unregistered direction");
            return false;
        }
      };
      Character.prototype.pickUp = function () {
        if(this.tileTo[0] != this.tileFrom[0] ||
          this.tileTo[1] != this.tileTo[1]){
          return false;
        }
        const is = mapTileData.map[toIndex(this.tileFrom[0], this.tileFrom[1])].itemStack;
        if(is!=null){
          const remains = this.inventory.addItems(is.type, is.qty)
          if(remains) is.qty = remains;
          else{
            mapTileData.map[toIndex(this.tileFrom[0], this.tileFrom[1])].itemStack = null;
          }
        }
        return true;
      }

      function toIndex(x, y) {
        return y * mapW + x;
      }

      window.onload = () => {
        ctx = document.getElementById("game").getContext("2d");
        requestAnimationFrame(drawGame);
        ctx.font = "bold 10pt sans-serif";

        window.addEventListener("keydown", (e) => {
          if (e.keyCode >= 37 && e.keyCode <= 40) {
            keysDown[e.keyCode] = true;
          }
          if (e.keyCode == 80){ keysDown[e.keyCode] = true;}
          if (e.keyCode === 83) {
            currentGameSpeed =
              currentGameSpeed >= gameSpeeds.length - 1
                ? 0
                : currentGameSpeed + 1;
          }
        });
        window.addEventListener("keyup", (e) => {
          if (e.keyCode >= 37 && e.keyCode <= 40) {
            keysDown[e.keyCode] = false;
          }
          if (e.keyCode == 80){ keysDown[e.keyCode] = false;}
        });

        viewport.screen = [
          document.getElementById("game").width,
          document.getElementById("game").height,
        ];

        tileset = new Image();
        tileset.onerror = function () {
          ctx = null;
          alert("Failed to loading tileset");
        };
        tileset.onload = function () {
          tilesetLoaded = true;
        };
        tileset.src = tilesetURL;

        for (x in tileTypes) {
          tileTypes[x]["animated"] = tileTypes[x].sprite.length > 1;
          if (tileTypes[x].animated) {
            let t = 0;
            for (s in tileTypes[x].sprite) {
              tileTypes[x].sprite[s]["start"] = t;
              t += tileTypes[x].sprite[s].d;
              tileTypes[x].sprite[s]["end"] = t;
            }
            tileTypes[x]["spriteDuration"] = t;
          }
        }
        mapTileData.buildMapFromData(gameMap, mapW, mapH);
        mapTileData.addRoofs(roofList);

        mapTileData.map[2 * mapW + 2].eventEnter = function () {
          console.log("Entered tile 2,2");
        };

        const mo1 = new MapObject(1);
        mo1.placeAt(2, 4);
        const mo2 = new MapObject(2);
        mo2.placeAt(2, 3);

        const mo11 = new MapObject(1);
        mo11.placeAt(6, 4);
        const mo12 = new MapObject(2);
        mo12.placeAt(7, 4);

        const mo4 = new MapObject(3);
        mo4.placeAt(4, 5);
        const mo5 = new MapObject(3);
        mo5.placeAt(4, 8);
        const mo6 = new MapObject(3);
        mo6.placeAt(4, 11);

        const mo7 = new MapObject(3);
        mo7.placeAt(2, 6);
        const mo8 = new MapObject(3);
        mo8.placeAt(2, 9);
        const mo9 = new MapObject(3);
        mo9.placeAt(2, 12);

        for(let i=3; i<8; i++){
          let ps = new PlacedItemStack(1, 1);
          ps.placeAt(i, 1);
        }

        for(let i=3; i<8; i++){
          let ps = new PlacedItemStack(1, 1);
          ps.placeAt(3, i);
        }
      };

      function getFrame(sprite, duration, time, animated) {
        if (!animated) {
          return sprite[0];
        }

        time = time % duration;

        for (x in sprite) {
          if (sprite[x].end >= time) {
            return sprite[x];
          }
        }
      }

      function drawGame() {
        if (ctx == null) return;
        if (!tilesetLoaded) {
          requestAnimationFrame(drawGame);
          return;
        }
        const currentFrameTime = Date.now();
        const timeElapsed = currentFrameTime - lastFrameTime;
        gameTime += Math.floor(timeElapsed * gameSpeeds[currentGameSpeed].mult);
        const sec = Math.floor(Date.now() / 1000);
        if (sec != currentSecond) {
          currentSecond = sec;
          framesLastSecond = frameCount;
          frameCount = 1;
        } else {
          frameCount++;
        }
        if (
          !player.processMovement(gameTime) &&
          gameSpeeds[currentGameSpeed].mult !== 0
        ) {
          if (keysDown[38] && player.canMoveUp()) {
            player.moveUp(gameTime);
          } else if (keysDown[40] && player.canMoveDown()) {
            player.moveDown(gameTime);
          } else if (keysDown[37] && player.canMoveLeft()) {
            player.moveLeft(gameTime);
          } else if (keysDown[39] && player.canMoveRight()) {
            player.moveRight(gameTime);
          } else if (keysDown[80]) {
            player.pickUp()
          }
        }

        viewport.update(
          player.position[0] + player.dimensions[0] / 2,
          player.position[1] + player.dimensions[1] / 2
        );

        let playerRoof1 =
          mapTileData.map[toIndex(player.tileFrom[0], player.tileFrom[1])].roof;
        let playerRoof2 =
          mapTileData.map[toIndex(player.tileTo[0], player.tileTo[1])].roof;

        // 나머지 검정으로 매꾸기
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, viewport.screen[0], viewport.screen[1]);

        // drawing with culling
        for (let z = 0; z < mapTileData.levels; z++) {
          for (let y = viewport.startTile[1]; y <= viewport.endTile[1]; y++) {
            for (let x = viewport.startTile[0]; x <= viewport.endTile[0]; x++) {
              if (z == 0) {
                let tile = tileTypes[mapTileData.map[toIndex(x, y)].type];
                let sprite = getFrame(
                  tile.sprite,
                  tile.spriteDuration,
                  gameTime,
                  tile.animated
                );
                ctx.drawImage(
                  tileset,
                  sprite.x,
                  sprite.y,
                  sprite.w,
                  sprite.h,
                  viewport.offset[0] + x * tileW,
                  viewport.offset[1] + y * tileH,
                  tileW,
                  tileH
                );
              }else if (z == 1){
                let is = mapTileData.map[toIndex(x, y)].itemStack;
                if (is != null) {
                  let sprite = itemTypes[is.type].sprite;
                  ctx.drawImage(tileset,
                          sprite[0].x, sprite[0].y,
                          sprite[0].w, sprite[0].h,
                          viewport.offset[0] + x * tileW + itemTypes[is.type].offset[0],
                          viewport.offset[1] + y * tileH + itemTypes[is.type].offset[1],
                          sprite[0].w, sprite[0].h
                  );
                }
              }
              const o = mapTileData.map[toIndex(x, y)].object;
              if (o != null && objectTypes[o.type].zIndex == z) {
                const ot = objectTypes[o.type];

                ctx.drawImage(
                  tileset,
                  ot.sprite[0].x,
                  ot.sprite[0].y,
                  ot.sprite[0].w,
                  ot.sprite[0].h,
                  viewport.offset[0] + x * tileW + ot.offset[0],
                  viewport.offset[1] + y * tileH + ot.offset[1],
                  ot.sprite[0].w,
                  ot.sprite[0].h
                );
              }
              if (
                z == 2 &&
                mapTileData.map[toIndex(x, y)].roofType != 0 &&
                mapTileData.map[toIndex(x, y)].roof != playerRoof1 &&
                mapTileData.map[toIndex(x, y)].roof != playerRoof2
              ) {
                tile = tileTypes[mapTileData.map[toIndex(x, y)].roofType];
                sprite = getFrame(
                  tile.sprite,
                  tile.spriteDuration,
                  gameTime,
                  tile.animated
                );
                ctx.drawImage(
                  tileset,
                  sprite.x,
                  sprite.y,
                  sprite.w,
                  sprite.h,
                  viewport.offset[0] + x * tileW,
                  viewport.offset[1] + y * tileH,
                  tileW,
                  tileH
                );
              }
            }
          }
          if (z == 1) {
            const sprite = player.sprites[player.direction];
            ctx.drawImage(
              tileset,
              sprite[0].x,
              sprite[0].y,
              sprite[0].w,
              sprite[0].h,
              viewport.offset[0] + player.position[0],
              viewport.offset[1] + player.position[1],
              player.dimensions[0],
              player.dimensions[1]
            );
          }
        } // end of Z-Index Loop

        // ctx.fillRect(viewport.offset[0]+player.position[0], viewport.offset[1]+player.position[1], player.dimensions[0], player.dimensions[1]);
        ctx.textAlign = "right";
        for(let i=0; i<player.inventory.spaces; i++){
          ctx.fillStyle = "#ddccaa";
          ctx.fillRect(10 + (i * 50), 350, 40, 40);
          if(typeof player.inventory.stacks[i] != 'undefined'){
            let it = itemTypes[player.inventory.stacks[i].type];
            let sprite = it.sprite;
            ctx.drawImage(
                    tileset,
                    sprite[0].x,
                    sprite[0].y,
                    sprite[0].w,
                    sprite[0].h,
                    10 + i * 50 + it.offset[0],
                    350 + it.offset[1],
                    sprite[0].w,
                    sprite[0].h
            )
            if(player.inventory.stacks[i].qty > 1){
              ctx.fillStyle = "#000000";ctx.fillText("" + player.inventory.stacks[i].qty,
              10+ (i*50) + 38, 350+38);
            }
          }
        }

        ctx.fillStyle = "#ff0000";
        ctx.fillText("FPS: " + framesLastSecond, 10, 20);
        ctx.fillText(
          "Game Speed: " + gameSpeeds[currentGameSpeed].name,
          10,
          40
        );
        lastFrameTime = currentFrameTime;
        requestAnimationFrame(drawGame);
      } // End of drawGame()
    </script>
  </head>
  <body>
    <canvas id="game" width="400" height="400"></canvas>
  </body>
</html>
