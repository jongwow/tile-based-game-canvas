<!DOCTYPE html>
<html>
  <head>
    <script type="text/javascript">
      let ctx = null;
      const tileW = 40, tileH = 40;
      const mapW = 10, mapH = 10;

      let currentSecond = 0, frameCount = 0, framesLastSecond = 0;
      let lastFrameTime = 0;

      const keysDown = {
        37: false, // LEFT
        38: false, // DOWN
        39: false, // UP
        40: false, // RIGHT
      };

      const player = new Character();
      console.log(player.tileFrom);

      const gameMap = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 1, 1, 1, 0, 1, 1, 1, 1, 0,
        0, 1, 0, 0, 0, 1, 0, 0, 0, 0,
        0, 1, 1, 1, 1, 1, 1, 1, 1, 0,
        0, 1, 0, 1, 0, 0, 0, 1, 1, 0,
        0, 1, 0, 1, 0, 1, 0, 0, 1, 0,
        0, 1, 1, 1, 1, 1, 1, 1, 1, 0,
        0, 1, 0, 0, 0, 0, 0, 1, 0, 0,
        0, 1, 1, 1, 1, 1, 1, 1, 1, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      ];

      function Character(){
        this.tileFrom = [1, 1]
        this.tileTo = [1,1]
        this.timeMoved = 0;
        this.dimensions = [30, 30];
        this.position = [45, 45];
        this.delayMove = 300;
      };
      Character.prototype.placeAt = function(x, y){
        console.log(x, y);
        this.tileFrom = [x, y];
        this.tileTo = [x, y];
        this.position = [
          ((tileW * x) + ((tileW - this.dimensions[0])/2)),
          ((tileH * y) + ((tileH - this.dimensions[1])/2)),
        ]
      };
      Character.prototype.processMovement = function(t){

        if(this.tileTo[0] == this.tileFrom[0] && this.tileTo[1] == this.tileFrom[1]){
          return false;
        }
        if ((t - this.timeMoved) >= this.delayMove){
          this.placeAt(this.tileTo[0], this.tileTo[1]);
        }else {
          // pixel position
          this.position[0] = (this.tileFrom[0] * tileW) + ((tileW - this.dimensions[0])/2);
          this.position[1] = (this.tileFrom[1] * tileH) + ((tileH - this.dimensions[1])/2);

          if (this.tileTo[0] != this.tileFrom[0]) { // Horizontally
            const diff = (tileW / this.delayMove) * (t - this.timeMoved);
            this.position[0] += (this.tileTo[0] < this.tileFrom[0]) ? 0 - diff : diff;
          }
          if(this.tileTo[1] != this.tileFrom[1]){ // Vertically
            const diff = (tileH / this.delayMove) * (t - this.timeMoved);
            this.position[1] += (this.tileTo[1] < this.tileFrom[1]) ? 0 - diff : diff;
          }
          this.position[0] = Math.round(this.position[0]);
          this.position[1] = Math.round(this.position[1]);
        }
        return true;
      }
      function toIndex(x, y){
        return ((y * mapW) + x);
      }

      window.onload = () => {
        ctx = document.getElementById('game').getContext('2d');
        requestAnimationFrame(drawGame);
        ctx.font = "bold 10pt sans-serif";

        window.addEventListener("keydown", (e) => {
          if(e.keyCode >= 37 && e.keyCode <= 40){
            keysDown[e.keyCode] = true;
          }
        });
        window.addEventListener("keyup", (e) => {
          if(e.keyCode >= 37 && e.keyCode <= 40){
            keysDown[e.keyCode] = false;
          }
        })
      };
      function drawGame() {
        if(ctx == null) return;
        const currentFrameTime = Date.now();
        const timeElapsed = currentFrameTime - lastFrameTime;
        const sec = Math.floor(Date.now()/1000);
        if(sec != currentSecond){
          currentSecond = sec;
          framesLastSecond = frameCount;
          frameCount= 1;
        }else{
          frameCount++;
        }
        if(!player.processMovement(currentFrameTime)){
           if(keysDown[38] && player.tileFrom[1] > 0 &&
             gameMap[toIndex(player.tileFrom[0], player.tileFrom[1]-1)] == 1){
             player.tileTo[1] -= 1;
           } else if (keysDown[40] && player.tileFrom[1] < (mapH - 1) &&
             gameMap[toIndex(player.tileFrom[0], player.tileFrom[1]+1)] == 1){
             player.tileTo[1] += 1;
           } else if(keysDown[37] && player.tileFrom[0] > 0 &&
             gameMap[toIndex(player.tileFrom[0]-1, player.tileFrom[1])] == 1){
             player.tileTo[0] -= 1;
           } else if (keysDown[39] && player.tileFrom[0] < (mapW - 1) &&
             gameMap[toIndex(player.tileFrom[0]+1, player.tileFrom[1])] == 1){
             player.tileTo[0] += 1;
           }
          if(player.tileFrom[0] != player.tileTo[0] ||
            player.tileFrom[1] != player.tileTo[1]){
            player.timeMoved = currentFrameTime;
          }
        }

        for(let y = 0; y < mapH; y++){
          for(let x = 0; x < mapW; x++){
            switch(gameMap[((y*mapW)+x)]){
              case 0:
                ctx.fillStyle = "#999999";
                break;
              default:
                ctx.fillStyle = "#eeeeee";
            }
            ctx.fillRect(x*tileW, y*tileH, tileW, tileH);
          }
        }

        ctx.fillStyle = "#0000ff";
        ctx.fillRect(player.position[0], player.position[1], player.dimensions[0], player.dimensions[1]);

        ctx.fillStyle = "#ff0000";
        ctx.fillText("FPS: "+framesLastSecond, 10, 20);

        lastFrameTime = currentFrameTime;
        requestAnimationFrame(drawGame);
      }

    </script>
  </head>
  <body>
    <canvas id="game" width="400" height="400"></canvas>
  </body>
</html>
